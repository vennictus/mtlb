#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

/*
    =============================
      GENERAL CPU SCHEDULING TEMPLATE
    =============================

    This file is a UNIVERSAL BLUEPRINT for:
        - Preemptive Scheduling
        - Non-preemptive Scheduling
        - Ready Queue Logic
        - Gantt Chart Logging
        - Computing WT, TAT, RT
        - ANY algorithm: FCFS, SJF, SRTF, Priority, RR, MWTF

    Replace ONLY the "SELECTION LOGIC" block during exam.
*/


// ========================================================
// Process structure (common to ALL scheduling algorithms)
// ========================================================
class Process {
public:
    char pid[10];        // Process ID
    int arrival;         // Arrival Time
    int burst;           // Burst Time (original)
    int remaining;       // Remaining Time (changes during execution)
    int executed;        // How many time units executed
    int waiting;         // Dynamic waiting time (if algorithm uses it)
    int start;           // First time process gets CPU
    int completion;      // Completion time

    Process() {
        strcpy(pid, "");
        arrival = burst = remaining = executed = waiting = 0;
        start = -1;
        completion = 0;
    }

    Process(const char p[], int at, int bt) {
        strcpy(pid, p);
        arrival = at;
        burst = bt;
        remaining = bt;
        executed = waiting = 0;
        start = -1;
        completion = 0;
    }
};


int main() {

    // ============================
    // Input Section
    // ============================
    int n;
    cout << "Enter number of processes: ";
    cin >> n;

    Process p[n];
    for (int i = 0; i < n; i++) {
        char id[10];
        int at, bt;
        cin >> id >> at >> bt;
        p[i] = Process(id, at, bt);
    }

    // ============================
    // Simulation Variables
    // ============================
    int currentTime = 0;
    int completed = 0;

    // Ready queue marker (true = in queue, false = not)
    bool inReady[n] = {false};

    // Gantt chart
    vector<string> gantt;


    // ======================================================
    //  MAIN SCHEDULING LOOP (universal for ALL algorithms)
    // ======================================================
    while (completed < n) {

        // -----------------------------------------
        // STEP 1: Add newly arrived processes
        // -----------------------------------------
        for (int i = 0; i < n; i++) {
            if (p[i].arrival == currentTime && p[i].remaining > 0) {
                inReady[i] = true;
            }
        }

        // -----------------------------------------
        // STEP 2: Update waiting times
        // NOTE:
        // For some algorithms (MWTF, Priority variations),
        // waiting = currentTime - arrival - executed
        // For others (FCFS, SJF), waiting is computed at end.
        // -----------------------------------------
        for (int i = 0; i < n; i++) {
            if (inReady[i] && p[i].remaining > 0) {
                p[i].waiting = currentTime - p[i].arrival - p[i].executed;
            }
        }


        // ======================================================
        // STEP 3: SELECTION LOGIC (ALGORITHM-DEPENDENT)
        // YOU REPLACE ONLY THIS BLOCK PER ALGORITHM
        // ------------------------------------------------------
        // EXAMPLES:
        // FCFS → choose ready process with earliest arrival
        // SJF  → choose ready process with smallest burst
        // SRTF → choose ready process with smallest remaining
        // PRIORITY → choose highest/lowest priority
        // RR → pick next from circular queue
        // MWTF → choose minimum waiting time
        // ======================================================

        int selected = -1;

        for (int i = 0; i < n; i++) {
            if (inReady[i] && p[i].remaining > 0) {

                if (selected == -1) {
                    selected = i;
                }

                // ------------------------------
                // PLACEHOLDER FOR TIE-BREAK RULES
                // Modify this depending on algorithm
                // ------------------------------
                // Example MWTF rule (replace when needed):
                /*
                if (p[i].waiting < p[selected].waiting) {
                    selected = i;
                }
                else if (p[i].waiting == p[selected].waiting) {
                    if (p[i].arrival < p[selected].arrival) selected = i;
                    else if (p[i].arrival == p[selected].arrival)
                        if (strcmp(p[i].pid, p[selected].pid) < 0) selected = i;
                }
                */

                // For exam: Replace the above block
                // with your specific scheduling rule
            }
        }


        // -----------------------------------------
        // STEP 4: CPU Idle Case
        // -----------------------------------------
        if (selected == -1) {
            gantt.push_back("IDLE");
            currentTime++;
            continue;
        }


        // -----------------------------------------
        // STEP 5: First Time CPU Allocation
        // -----------------------------------------
        if (p[selected].start == -1) {
            p[selected].start = currentTime;
        }


        // Log Gantt Chart
        gantt.push_back(p[selected].pid);


        // -----------------------------------------
        // STEP 6: Execute ONE time unit (Preemptive)
        // -----------------------------------------
        p[selected].executed++;
        p[selected].remaining--;


        // -----------------------------------------
        // STEP 7: Completion Check
        // -----------------------------------------
        if (p[selected].remaining == 0) {
            p[selected].completion = currentTime + 1;
            inReady[selected] = false;
            completed++;
        }


        // -----------------------------------------
        // STEP 8: Move Simulation Clock
        // -----------------------------------------
        currentTime++;
    }


    // ======================================================
    // FINAL METRIC CALCULATIONS (same for ALL algorithms)
    // ======================================================
    cout << "\n\nProcess Table:\n";
    cout << "PID\tAT\tBT\tST\tCT\tTAT\tWT\tRT\n";

    double totalWT = 0, totalTAT = 0, totalRT = 0;

    for (int i = 0; i < n; i++) {

        int TAT = p[i].completion - p[i].arrival;
        int WT  = TAT - p[i].burst;
        int RT  = p[i].start - p[i].arrival;

        totalWT  += WT;
        totalTAT += TAT;
        totalRT  += RT;

        cout << p[i].pid << "\t"
             << p[i].arrival << "\t"
             << p[i].burst << "\t"
             << p[i].start << "\t"
             << p[i].completion << "\t"
             << TAT << "\t"
             << WT << "\t"
             << RT << endl;
    }

    cout << "\nAverage Waiting Time: "    << totalWT / n;
    cout << "\nAverage Turnaround Time: " << totalTAT / n;
    cout << "\nAverage Response Time: "   << totalRT / n;


    // ======================================================
    // PRINT GANTT CHART (same for ALL algorithms)
    // ======================================================
    cout << "\n\nGantt Chart:\n0 ";
    for (auto &g : gantt) {
        cout << "| " << g << " ";
    }
    cout << "| " << gantt.size() << endl;

    return 0;
}
