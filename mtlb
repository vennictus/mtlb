#include <iostream>
#include <vector>
#include <cstring>
using namespace std;

/*
    =============================
      GENERAL CPU SCHEDULING TEMPLATE
    =============================

    This file is a UNIVERSAL BLUEPRINT for:
        - Preemptive Scheduling
        - Non-preemptive Scheduling
        - Ready Queue Logic
        - Gantt Chart Logging
        - Computing WT, TAT, RT
        - ANY algorithm: FCFS, SJF, SRTF, Priority, RR, MWTF

    Replace ONLY the "SELECTION LOGIC" block during exam.
*/


// ========================================================
// Process structure (common to ALL scheduling algorithms)
// ========================================================
class Process {
public:
    char pid[10];        // Process ID
    int arrival;         // Arrival Time
    int burst;           // Burst Time (original)
    int remaining;       // Remaining Time (changes during execution)
    int executed;        // How many time units executed
    int waiting;         // Dynamic waiting time (if algorithm uses it)
    int start;           // First time process gets CPU
    int completion;      // Completion time

    Process() {
        strcpy(pid, "");
        arrival = burst = remaining = executed = waiting = 0;
        start = -1;
        completion = 0;
    }

    Process(const char p[], int at, int bt) {
        strcpy(pid, p);
        arrival = at;
        burst = bt;
        remaining = bt;
        executed = waiting = 0;
        start = -1;
        completion = 0;
    }
};


int main() {

    // ============================
    // Input Section
    // ============================
    int n;
    cout << "Enter number of processes: ";
    cin >> n;

    Process p[n];
    for (int i = 0; i < n; i++) {
        char id[10];
        int at, bt;
        cin >> id >> at >> bt;
        p[i] = Process(id, at, bt);
    }

    // ============================
    // Simulation Variables
    // ============================
    int currentTime = 0;
    int completed = 0;

    // Ready queue marker (true = in queue, false = not)
    bool inReady[n] = {false};

    // Gantt chart
    vector<string> gantt;


    // ======================================================
    //  MAIN SCHEDULING LOOP (universal for ALL algorithms)
    // ======================================================
    while (completed < n) {

        // -----------------------------------------
        // STEP 1: Add newly arrived processes
        // -----------------------------------------
        for (int i = 0; i < n; i++) {
            if (p[i].arrival == currentTime && p[i].remaining > 0) {
                inReady[i] = true;
            }
        }

        // -----------------------------------------
        // STEP 2: Update waiting times
        // NOTE:
        // For some algorithms (MWTF, Priority variations),
        // waiting = currentTime - arrival - executed
        // For others (FCFS, SJF), waiting is computed at end.
        // -----------------------------------------
        for (int i = 0; i < n; i++) {
            if (inReady[i] && p[i].remaining > 0) {
                p[i].waiting = currentTime - p[i].arrival - p[i].executed;
            }
        }


        // ======================================================
        // STEP 3: SELECTION LOGIC (ALGORITHM-DEPENDENT)
        // YOU REPLACE ONLY THIS BLOCK PER ALGORITHM
        // ------------------------------------------------------
        // EXAMPLES:
        // FCFS → choose ready process with earliest arrival
        // SJF  → choose ready process with smallest burst
        // SRTF → choose ready process with smallest remaining
        // PRIORITY → choose highest/lowest priority
        // RR → pick next from circular queue
        // MWTF → choose minimum waiting time
        // ======================================================

        int selected = -1;

        for (int i = 0; i < n; i++) {
            if (inReady[i] && p[i].remaining > 0) {

                if (selected == -1) {
                    selected = i;
                }

                // ------------------------------
                // PLACEHOLDER FOR TIE-BREAK RULES
                // Modify this depending on algorithm
                // ------------------------------
                // Example MWTF rule (replace when needed):
                /*
                if (p[i].waiting < p[selected].waiting) {
                    selected = i;
                }
                else if (p[i].waiting == p[selected].waiting) {
                    if (p[i].arrival < p[selected].arrival) selected = i;
                    else if (p[i].arrival == p[selected].arrival)
                        if (strcmp(p[i].pid, p[selected].pid) < 0) selected = i;
                }
                */

                // For exam: Replace the above block
                // with your specific scheduling rule
            }
        }


        // -----------------------------------------
        // STEP 4: CPU Idle Case
        // -----------------------------------------
        if (selected == -1) {
            gantt.push_back("IDLE");
            currentTime++;
            continue;
        }


        // -----------------------------------------
        // STEP 5: First Time CPU Allocation
        // -----------------------------------------
        if (p[selected].start == -1) {
            p[selected].start = currentTime;
        }


        // Log Gantt Chart
        gantt.push_back(p[selected].pid);


        // -----------------------------------------
        // STEP 6: Execute ONE time unit (Preemptive)
        // -----------------------------------------
        p[selected].executed++;
        p[selected].remaining--;


        // -----------------------------------------
        // STEP 7: Completion Check
        // -----------------------------------------
        if (p[selected].remaining == 0) {
            p[selected].completion = currentTime + 1;
            inReady[selected] = false;
            completed++;
        }


        // -----------------------------------------
        // STEP 8: Move Simulation Clock
        // -----------------------------------------
        currentTime++;
    }


    // ======================================================
    // FINAL METRIC CALCULATIONS (same for ALL algorithms)
    // ======================================================
    cout << "\n\nProcess Table:\n";
    cout << "PID\tAT\tBT\tST\tCT\tTAT\tWT\tRT\n";

    double totalWT = 0, totalTAT = 0, totalRT = 0;

    for (int i = 0; i < n; i++) {

        int TAT = p[i].completion - p[i].arrival;
        int WT  = TAT - p[i].burst;
        int RT  = p[i].start - p[i].arrival;

        totalWT  += WT;
        totalTAT += TAT;
        totalRT  += RT;

        cout << p[i].pid << "\t"
             << p[i].arrival << "\t"
             << p[i].burst << "\t"
             << p[i].start << "\t"
             << p[i].completion << "\t"
             << TAT << "\t"
             << WT << "\t"
             << RT << endl;
    }

    cout << "\nAverage Waiting Time: "    << totalWT / n;
    cout << "\nAverage Turnaround Time: " << totalTAT / n;
    cout << "\nAverage Response Time: "   << totalRT / n;


    // ======================================================
    // PRINT GANTT CHART (same for ALL algorithms)
    // ======================================================
    cout << "\n\nGantt Chart:\n0 ";
    for (auto &g : gantt) {
        cout << "| " << g << " ";
    }
    cout << "| " << gantt.size() << endl;

    return 0;
}
#include <iostream>
#include <vector>
#include <iomanip>
using namespace std;






/*
    ================================================================
      UNIVERSAL PAGE REPLACEMENT TEMPLATE (C++ BLUEPRINT)
    ================================================================

    This file is a GENERAL skeleton to implement ANY page algorithm:

        → FIFO
        → LRU
        → LFU
        → Optimal
        → IAR (Inverse Age Replacement)
        → Random
        → Custom replacement strategies

    You ONLY modify ONE PART:
        **THE VICTIM SELECTION LOGIC**

    Everything else stays the same.
*/

// Frame structure
struct Frame {
    int page;           // page number stored
    int last_access;    // last used time (LRU / IAR)
    int frequency;      // how many times used (LFU / IAR)
    int arrival_time;   // when inserted (FIFO)

    Frame() {
        page = -1;              // empty marker
        last_access = -1;
        frequency = 0;
        arrival_time = -1;
    }
};

int main() {

    int F, N;
    cout << "Enter number of frames: ";
    cin >> F;

    cout << "Enter number of references: ";
    cin >> N;

    vector<int> ref(N);
    cout << "Enter reference string:\n";
    for (int i = 0; i < N; i++) cin >> ref[i];

    vector<Frame> frames(F);

    int hits = 0, faults = 0;

    cout << "\nRef\tFrames\t\tStatus\n";

    // =====================================================
    // MAIN LOOP — iterate through reference string
    // =====================================================
    for (int t = 0; t < N; t++) {

        int curr = ref[t];
        bool hit = false;

        // -------------------------------------------------
        // STEP 1 — CHECK IF PAGE IS ALREADY LOADED (HIT)
        // -------------------------------------------------
        for (int i = 0; i < F; i++) {
            if (frames[i].page == curr) {
                hit = true;
                hits++;

                // Update metadata depending on algorithm
                frames[i].last_access = t; // used by LRU / IAR
                frames[i].frequency++;     // used by LFU / IAR

                break;
            }
        }

        if (hit) {
            cout << curr << "\t";
            for (int i = 0; i < F; i++)
                cout << frames[i].page << " ";
            cout << "\tHIT\n";
            continue;
        }

        // -------------------------------------------------
        // STEP 2 — FAULT OCCURS
        // -------------------------------------------------
        faults++;

        bool inserted = false;

        // Check for free frame first
        for (int i = 0; i < F; i++) {
            if (frames[i].page == -1) {
                frames[i].page = curr;
                frames[i].last_access = t;
                frames[i].frequency = 1;
                frames[i].arrival_time = t;

                inserted = true;
                break;
            }
        }

        // -------------------------------------------------
        // STEP 3 — NEED REPLACEMENT (Memory Full)
        // -------------------------------------------------
        if (!inserted) {

            int victim = -1;

            /*
                ===================================================
                        VICTIM SELECTION LOGIC (EDIT THIS)
                ===================================================

                Examples:

                FIFO:
                    choose smallest arrival_time

                LRU:
                    choose smallest last_access

                LFU:
                    choose smallest frequency

                OPT:
                    choose page used farthest in future

                IAR:
                    age = t - last_access
                    score = age / (1 + frequency)
                    choose maximum score

                Below is a GENERAL FORM:

                    compute "score" for each frame
                    choose frame with best score

                YOU WILL MODIFY THIS PART IN THE EXAM.
            */

            double bestScore = -1e18;   // very small number

            for (int i = 0; i < F; i++) {

                // --------------------------------------------
                // DEFAULT: score = 0 (YOU CHANGE THIS)
                // --------------------------------------------
                double score = 0;

                // Example IAR (commented):
                /*
                double age = t - frames[i].last_access;
                score = age / (1 + frames[i].frequency);
                */

                // choose victim with highest score
                if (score > bestScore) {
                    bestScore = score;
                    victim = i;
                }
            }

            // --------------------------------------------
            // REPLACE THE VICTIM
            // --------------------------------------------
            frames[victim].page = curr;
            frames[victim].last_access = t;
            frames[victim].frequency = 1;
            frames[victim].arrival_time = t;
        }

        // -------------------------------------------------
        // STEP 4 — PRINT MEMORY STATE AFTER THIS REFERENCE
        // -------------------------------------------------
        cout << curr << "\t";
        for (int i = 0; i < F; i++)
            cout << frames[i].page << " ";
        cout << "\tFAULT\n";
    }


    // =====================================================
    // FINAL STATISTICS
    // =====================================================
    cout << "\nTotal Hits : " << hits;
    cout << "\nTotal Faults : " << faults;
    cout << "\nHit Ratio : " << fixed << setprecision(2) 
         << (float)hits / N;
    cout << "\nFault Ratio : " << fixed << setprecision(2) 
         << (float)faults / N << "\n";

    return 0;
}
